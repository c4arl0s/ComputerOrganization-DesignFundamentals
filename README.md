# Computer Organization and Design Fundamentals

# 1. [Chapter One: Digital Signals and Systems](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)
# 2. [Chapter Two: Numbering Systems]()
# 3. [Chapter Three: Binary Math and Signed Representations]()
# 4. [Chapter Four: Logic Functions and Gates]()
# 5. [Chapter Five: Boolean Algebra]()
# 6. [Chapter Six: Standard Boolean Expression Formats]()
# 7. [Chapter Seven: Karnaugh Maps]()
# 8. [Chapter Eight: Combinational Logic Applications]()
# 9. [Chapter Nine: Binary Operation Applications]()
# 10.[ Chapter Ten: Memory Cells]()
# 11.[ Chapter Eleven: State Machines]()
# 12.[ Chapter Twelve: Memory Organization]()
# 13.[ Chapter Thirteen: Memory Hierarchy]()
# 14.[ Chapter Fourteen: Serial Protocol Basics]()
# 15.[ Chapter Fifteen: Introduction to Processor Architecture]()
# 16.[ Chapter Sixteen: Intel 80x86 Base Architecture]()

# 1. [Chapter One: Digital Signals and Systems](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#computer-organization-and-design-fundamentals)
 * [1.1 Should Software Engineers Worry About Hardware?](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-11-should-software-engineers-worry-about-hardware)
 * [1.2 Non-Digital Signal](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-12-non-digital-signal)
 * [1.3 Digital Signals](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-13-digital-signals)
 * [1.4 Conversion Systems](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-14-conversion-systems)
 * [1.5 Representation of Digital Signals](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-15-representation-of-digital-signals)
 * [1.6 Types of Digital Signals](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-16-types-of-digital-signals)
 * [1.6.1 Edges](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-161-edges)
 * [1.6.2 Pulses](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-162-pulses)
 * [1.6.3 Non-Periodic Pulse Trains](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-163-non-periodic-pulse-trains)
 * [1.6.4 Periodic Pulse Trains](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-164-periodic-pulse-trains)
 * [1.6.5 Pulse-Width Modulation](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-165-pulse-width-modulation)
 * [1.7 Unit Prefixes](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-17-unit-prefixes)
 * [1.8 What's Next?](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-18-whats-next)
 * [Problems](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#-problems)

# 2. [Chapter Two: Numbering Systems]()
 * [2.1 Unsigned Binary Counting]()
 * [2.2 Binary Terminology]()
 * [2.3 Unsigned Binary to Decimal Conversion]()
 * [2.4 Decimal to Unsigned Binary Conversion]()
 * [2.5 Binary Representation of Analog Values]()
 * [2.6 Sampling Theory]()
 * [2.7 Hexadecimal Representation]()
 * [2.8 Binary Coded Decimal]()
 * [2.9 Gray Codes]()
 * [2.10 What's Next?]()
 * [Problems]()

# 3. [Chapter Three: Binary Math and Signed Representations]()
 * [3.1 Binary Addition]()
 * [3.2 Binary Subtraction]()
 * [3.3 Binary Complements]()
 * [3.3.1 One's Complement]()
 * [3.3.2 Two's Complement]()
 * [3.3.3 Most Significant Bit as a Sign Indicator]()
 * [3.3.4 Signed Magnitude]()
 * [3.3.5 MSB and Number of Bits]()
 * [3.3.6 Issues Surrounding the Conversion of Binary Numbers. 52 ]()
 * [3.3.7 Minimums and Maximums]()
 * [3.4 Floating Point Binary]()
 * [3.5 Hexadecimal Addition]()
 * [3.6 BCD Addition]()
 * [3.7 Multiplication and Division by Powers of Two]()
 * [3.8 Easy Decimal to Binary Conversion Trick]()
 * [3.9 Arithmetic Overflow]()
 * [3.10 What's Next?]()
 * [Problems]()

# 4. [Chapter Four: Logic Functions and Gates]()
 * [4.1 Logic Gate Basics]()
 * [4.1.1 NOT Gate]()
 * [4.1.2 AND Gate]()
 * [4.1.3 OR Gate]()
 * [4.1.4 Exclusive-OR (XOR) Gate]()
 * [4.2 Truth Tables]()
 * [4.3 Timing Diagrams for Gates]()
 * [4.4 Combinational Logic]()
 * [4.5 Truth Tables for Combinational Logic]()
 * [4.6 What's Next?]()
 * [Problems]()

# 5. [Chapter Five: Boolean Algebra]()
 * [5.1 Need for Boolean Expressions]()
 * [5.2 Symbols of Boolean Algebra]()
 * [5.3 Boolean Expressions of Combinational Logic]()
 * [5.4 Laws of Boolean Algebra]()
 * [5.5 Rules of Boolean Algebra]()
 * [5.5.1 NOT Rule]()
 * [5.5.2 OR Rules]()
 * [5.5.3 AND Rules]()
 * [5.5.4 XOR Rules]()
 * [5.5.5 Derivation of Other Rules]()
 * [5.6 Simplification]()
 * [5.7 DeMorgan's Theorem]()
 * [5.8 What's Next?]()
 * [Problems]()

# 6. [Chapter Six: Standard Boolean Expression Formats]()
 * [6.1 Sum-of-Products]()
 * [6.2 Converting an SOP Expression to a Truth Table]()
 * [6.3 Converting a Truth Table to an SOP Expression]()
 * [6.4 Product-of-Sums]()
 * [6.5 Converting POS to Truth Table]()
 * [6.6 Converting a Truth Table to a POS Expression]()
 * [6.7 NAND-NAND Logic]()
 * [6.8 What's Next?]()
 * [Problems]()

# 7. [Chapter Seven: Karnaugh Maps]()
 * [7.1 The Karnaugh Map]()
 * [7.2 Using Karnaugh Maps]()
 * [7.3 "Don't Care" Conditions in a Karnaugh Map]()
 * [7.4 What's Next?]()
 * [Problems]()

# 8. [Chapter Eight: Combinational Logic Applications]()
 * [8.1 Adders]()
 * [8.2 Seven-Segment Displays]()
 * [8.3 Active-Low Signals]()
 * [8.4 Decoders]()
 * [8.5 Multiplexers]()
 * [8.6 Demultiplexers]()
 * [8.7 Integrated Circuits]()
 * [8.8 What's Next?]()
 * [Problems]()

# 9. [Chapter Nine: Binary Operation Applications]()
 * [9.1 Bitwise Operations]()
 * [9.2 Comparing Bits with XOR]()
 * [9.3 Parity]()
 * [9.4 Checksum]()
 * [9.5 Cyclic Redundancy Check]()
 * [9.5.1 CRC Process]()
 * [9.5.2 CRC Implementation]()
 * [9.6 Hamming Code]()
 * [9.7 What's Next?]()
 * [Problems]()

# 10.[ Chapter Ten: Memory Cells]()
 * [10.1 New Truth Table Symbols]()
 * [10.1.1 Edges/Transitions]()
 * [10.1.2 Previously Stored Values]()
 * [10.1.3 Undefined Values]()
 * [10.2 The S-R Latch]()
 * [10.3 The D Latch]()
 * [10.4 Divide-By-Two Circuit]()
 * [10.5 Counter]()
 * [10.6 Parallel Data Output]()
 * [10.7 What's Next?]()
 * [Problems]()

# 11.[ Chapter Eleven: State Machines]()
 * [11.1 Introduction to State Machines]()
 * [11.1.1 States]()
 * [11.1.2 State Diagrams]()
 * [11.1.3 Errors in State Diagrams]()
 * [11.1.4 Basic Circuit Organization]()
 * [11.2 State Machine Design Process]()
 * [11.3 Another State Machine Design: Pattern Detection]()
 * [11.4 Mealy Versus Moore State Machines]()
 * [11.5 What's Next?]()
 * [Problems]()

# 12.[ Chapter Twelve: Memory Organization]()
 * [12.1 Early Memory]()
 * [12.2 Organization of Memory Device]()
 * [12.3 Interfacing Memory to a Processor]()
 * [12.3.1 Buses]()
 * [12.3.2 Memory Maps]()
 * [12.3.3 Address Decoding]()
 * [12.3.4 Chip Select Hardware]()
 * [12.4 Memory Mapped Input/Output]()
 * [12.5 Memory Terminology]()
 * [12.5.1 Random Access Memory]()
 * [12.5.2 Read Only Memory]()
 * [12.5.3 Static RAM versus Dynamic RAM]()
 * [12.5.4 Types of DRAM and Their Timing]()
 * [12.5.5 Asynchronous vs. Synchronous Memory]()
 * [12.6 What's Next?]()
 * [Problems]()

# 13.[ Chapter Thirteen: Memory Hierarchy]()
 * [13.1 Characteristics of the Memory Hierarchy]()
 * [13.2 Physical Characteristics of a Hard Drive]()
 * [13.2.1 Hard Drive Read/Write Head]()
 * [13.2.2 Data Encoding]()
 * [13.2.3 Hard Drive Access Time]()
 * [13.2.4 S.M.A.R.T.]()
 * [13.3 Organization of Data on a Hard Drive]()
 * [13.4 Cache RAM]()
 * [13.4.1 Cache Organization]()
 * [13.4.2 Dividing Memory into Blocks]()
 * [13.4.3 Cache Operation]()
 * [13.4.4 Cache Characteristics]()
 * [13.4.5 Cache Mapping Functions]()
 * [13.4.6 Cache Write Policy]()
 * [13.5 Registers]()
 * [13.6 What's Next?]()
 * [Problems]()

# 14.[ Chapter Fourteen: Serial Protocol Basics]()
 * [14.1 OSI Seven-Layer Network Model]()
 * [14.2 Serial versus Parallel Data Transmission]()
 * [14.3 Anatomy of a Frame or Packet]()
 * [14.4 Sample Protocol: IEEE 802.3 Ethernet]()
 * [14.5 Sample Protocol: Internet Protocol]()
 * [14.6 Sample Protocol: Transmission Control Protocol]()
 * [14.7 Dissecting a Frame]()
 * [14.8 Additional Resources]()
 * [14.9 What's Next?]()
 * [Problems]()

# 15.[ Chapter Fifteen: Introduction to Processor Architecture]()
 * [15.1 Organization versus Architecture]()
 * [15.2 Components]()
 * [15.2.1 Bus]()
 * [15.2.2 Registers]()
 * [15.2.3 Flags]()
 * [15.2.4 Buffers]()
 * [15.2.5 The Stack]()
 * [15.2.6 I/O Ports]()
 * [15.3 Processor Level]()
 * [15.4 CPU Level]()
 * [15.5 Simple Example of CPU Operation]()
 * [15.6 Assembly and Machine Language]()
 * [15.7 Big-Endian/Little-Endian]()
 * [15.8 Pipelined Architectures]()
 * [15.9 Passing Data To and From Peripherals]()
 * [15.9.1 Memory-Mapped I/O]()
 * [15.9.2 Polling]()
 * [15.9.3 Interrupts]()
 * [15.9.4 Direct Memory Access]()
 * [15.9.5 I/O Channels and Processors]()
 * [15.10 What's Next?]()
 * [Problems]()

# 16.[ Chapter Sixteen: Intel 80x86 Base Architecture]()
 * [16.1 Why Study the 80x86?]()
 * [16.2 Execution Unit]()
 * [16.2.1 General Purpose Registers]()
 * [16.2.2 Address Registers]()
 * [16.2.3 Flags]()
 * [16.2.4 Internal Buses]()
 * [16.3 Bus Interface Unit]()
 * [16.3.1 Segment Addressing]()
 * [16.3.2 Instruction Queue]()
 * [16.4 Memory versus I/O Ports]()
 * [16.5 What's Next?]()
 * [Problems]()

# 17.[ Chapter Seventeen: Intel 80x86 Assembly Language]()
 * [17.1 Assemblers versus Compilers]()
 * [17.2 Components of a Line of Assembly Language]()
 * [17.3 Assembly Language Directives]()
 * [17.3.1 SEGMENT Directive]()
 * [17.3.2 .MODEL, .STACK, .DATA, and .CODE Directives . 380 ]()
 * [17.3.3 PROC Directive]()
 * [17.3.4 END Directive]()
 * [17.3.5 Data Definition Directives]()
 * [17.3.6 EQU Directive]()
 * [17.4 80x86 Opcodes]()
 * [17.4.1 Data Transfer]()
 * [17.4.2 Data Manipulation]()
 * [17.4.3 Program Control]()
 * [17.4.4 Special Operations]()
 * [17.5 Addressing Modes]()
 * [17.5.1 Register Addressing]()
 * [17.5.2 Immediate Addressing]()
 * [17.5.3 Pointer Addressing]()
 * [17.6 Sample 80x86 Assembly Language Programs]()
 * [17.7 Additional 80x86 Programming Resources]()
 * [17.8 What's Next?]()
 * [Problems]()


# Computer Organization and Design Fundamentals

# 1. [Chapter One: Digital Signals and Systems](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

Knowing how to design and build a computer may not be vital to the computer professional, but it goes a long way toward improving their skills, but example, making them better drivers.

The principles of computer organization provide tools to create better designs.

	* System Design Tools.
	* Software Design Tools.
	* Improved troubleshooting skills.
	* Interconnectivity
	* Marketability

> When you control parts design, you can integrate the whole package much more elegantly.

# * [1.1 Should Software Engineers Worry About Hardware?](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)


![Screen Shot 2020-06-05 at 15 23 34](https://user-images.githubusercontent.com/24994818/83919628-9f43fd00-a740-11ea-910f-f5257759b79e.png)

# * [1.2 Non-Digital Signal](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

The real world is analog. When values such as temperature or weight change over time, they follow what is called a **continuous curve**. It is sufficient to say that analog values represent a continuous signal with infinitesimal resolution.

# * [1.3 Digital Signals](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

There is such a thing as an analog computer, a computer that processes information using analog levels of electricity or the positions of mechanical devices. Now computers represent an analog value by converting it to a number with a fixed resolution. This measurement is referred to as a **digital value**.

![Screen Shot 2020-06-06 at 13 03 35](https://user-images.githubusercontent.com/24994818/83951299-269f7800-a7f6-11ea-858b-63451d4794b2.png)

The computer can only measure the signal at intervals. Each measurement is called a **sample**. The rate at which these samples are taken is called the **Sampling rate**.

![Screen Shot 2020-06-06 at 13 05 13](https://user-images.githubusercontent.com/24994818/83951333-61091500-a7f6-11ea-9c89-f0d55adb0702.png)

Two problem arise from this process: information can be lost between the measurement and information can be lost due to the **rounding** of the measurement. First, if the sampling rate is too slow, the some details of the signal may be missed.

![Screen Shot 2020-06-06 at 13 07 18](https://user-images.githubusercontent.com/24994818/83951375-ac232800-a7f6-11ea-8b82-7b3a0126502b.png)

Second, if the computer does not record with enough accuracy an error may be introduced between the actual measurement and the recorded value.

![Screen Shot 2020-06-06 at 13 08 48](https://user-images.githubusercontent.com/24994818/83951394-e42a6b00-a7f6-11ea-87a2-fff593ffe989.png)

These effects can be reduced by increasing the resolution of the measurement and increasing the sampling rate. A discussion of this can be found in Chapter 2 in the section titled "Sampling Theory"	

# * [1.4 Conversion Systems](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

The typical system used to convert an external condition such as pressure, temperature, or light intensity to a format usable by a digital system is shown in the block diagram.

![Screen Shot 2020-06-07 at 12 00 01](https://user-images.githubusercontent.com/24994818/83974936-72195b00-a8b6-11ea-8ac5-3703e364fea6.png)

The interface between the external condition and the electronics of the system is the sensor. This device converts the environmental conditions into a signal readable by analog electronics. Often, this signal is weak and is easily distorted by noise. Therefore, the output of the sensor is usually amplified and cleaned up before being converted to digital values by the Analog-to-Digital Converter (ADC).

Continuous operation of this system results in a sequence of digital measurements or samples that are stored in the computer where it can be viewed much like the table of numbers in a spreadsheet.

First benefit of digital systems: If an analog signal is transmitted over long distances, noise attaches itself to the signal. To keep the signal strong enough to reach its destination,it must be amplified. All of the noise attached itself to the signal, however, is amplified along with the original signal resulting in distortion. 

Noise cannot attach itself to a digital signal. Once an analog signal has been converted to a sequence of numbers, the signal's characteristics remain the same as long as the number don't change. Therefore, digital systems such as contemporary long-distance phone system do not suffer from degradation over long distances.

A second benefit is that once a signal is turned into a sequence of numbs, mathematical algorithms can be used to operate on the data. Disciplines such as Digital Signal Processing and the study of wavelets allow for much more accurate processing of signals that analog systems were ever able to achieve.

These advantages come at a price, however. As mentioned earlier, if the samples are taken too slowly, details of the analog input are missed. It the resolution of the samples is not fine enough, the signal may not be precisely represented with the signal values. Last of all, additional hardware is required to convert the signal from analog to digital

# * [1.5 Representation of Digital Signals](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

Digital Systems do not store numbers the way humans do. Digital systems work with numbs using millions of tiny switches called transistors. Each transistor can remember only one f two possible values, on or off. This referred to as a **binary system**.

The complexity of the computer comes in how the millions of transistors are designed to work together. The purpose of this discussion, the two values of a transistor will be referred to as **logic 1** and **logic 0**.

![Screen Shot 2020-06-08 at 18 01 42](https://user-images.githubusercontent.com/24994818/84088447-21872800-a9b2-11ea-9a44-da484e46bd53.png)

Sometimes, two or more binary lines are grouped together to perform a single function. 

![Screen Shot 2020-06-08 at 18 02 44](https://user-images.githubusercontent.com/24994818/84088508-44b1d780-a9b2-11ea-9afc-8a9e032bfa1a.png)

Alternatively, multiple lines can be combined into a more abstract representation such as the one shown in Figure 1-10

![Screen Shot 2020-06-08 at 18 04 00](https://user-images.githubusercontent.com/24994818/84088582-71fe8580-a9b2-11ea-900c-0d08793f68a6.png)

Hash marks indicate invalid or changing data. This could mean that one or all of the signals are changing their values, or that due to the nature of the electronics, the values of the data signals cannot be predicted. In the later case, the system may need to wait to allow the signals to stabilize. 

# * [1.6 Types of Digital Signals](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)
# * [1.6.1 Edges](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

A single binary signal can have one of two possible transitions as shown in figure 1-11. The first one, a transition from a logic 0 to a logic 1, is called a rising edge transition. The second one, a transition from a logic 1 to a logic 0 is called a falling edge transition.

![Screen Shot 2020-06-08 at 18 12 18](https://user-images.githubusercontent.com/24994818/84089054-9dce3b00-a9b3-11ea-82e0-76c251d12674.png)

# * [1.6.2 Pulses]()

A binary pulse occurs when a signal changes from one value to the other for a short period, then returns to its originals value. Examples of this type of signal might be the power-on or reset buttons on a computer (momentarily pressed, the released) or the button used to initialize synchronization between a PDA and a computer.

![Screen Shot 2020-06-08 at 18 13 08](https://user-images.githubusercontent.com/24994818/84089084-b9d1dc80-a9b3-11ea-8647-b3e49af21a70.png)

There are two types of pulses. The first is called a **positive-going-pulse**, and it has an idle state of logic 0 with a short pulse to logic 1. The other one, a **negative-going pulse**, has an idle state of logic 1 with a short pulse to logic 0. Both of these signals are shown in Figure-1-12.

# * [1.6.3 Non-Periodic Pulse Trains](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

Some digital signals such as the data wires of an Ethernet link or the data and address lines of a memory interface do not have a characteristic pattern in their changes between logic 1 and logic 0. These are called **non-periodic pulse trains**

![Screen Shot 2020-06-08 at 18 18 44](https://user-images.githubusercontent.com/24994818/84089414-86438200-a9b4-11ea-8c43-9d8d81090287.png)

Like music, the duration of the notes or the spaces between the notes can be longer or shorter. On the page, they do not look meaningful, but once the reader is given the tools to interpret the signal, he data they contain becomes clear.

# * [1.6.4 Periodic Pulse Trains](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

Some signals act as the heartbeat to a digital systems. Periodic pulse trains is meat to synchronized events or keep processes moving.

![Screen Shot 2020-06-09 at 13 36 54](https://user-images.githubusercontent.com/24994818/84186574-5947ab80-aa56-11ea-8d75-1381c6b0c827.png)

![Screen Shot 2020-06-09 at 13 37 49](https://user-images.githubusercontent.com/24994818/84186627-6d8ba880-aa56-11ea-9b80-2eb9cbb9f4a0.png)

Frequency = 1 / Period [seconds]

# * [1.6.5 Pulse-Width Modulation](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

The last measurement of a periodic waveform is the **duty cycle**. The duty cycle represents the percentage of time that a periodic signal is a logic 1. 

![Screen Shot 2020-06-09 at 13 40 36](https://user-images.githubusercontent.com/24994818/84186884-d07d3f80-aa56-11ea-8eda-203e280a6815.png)

Duty Cycle = ((logic 1 pulse duration) [seconds] / period [Seconds] ) * 100%

# * [1.7 Unit Prefixes](https://github.com/c4arl0s/ComputerOrganization-DesignFundamentals#1-chapter-one-digital-signals-and-systems-1)

![Screen Shot 2020-06-09 at 13 44 01](https://user-images.githubusercontent.com/24994818/84187367-8f395f80-aa57-11ea-9004-5a21b5cbac9b.png)

# * [1.8 What's Next?]()

In this chapter, we have seen how the methods that a computer uses to store and interpret values are different from the ways in which those values appear in the real world. We have also seen some of the methods used to measure and represent these digital signals.

In Chapter 2 we will see how digital values are used to represent integers. This is the first major step toward understanding some of the idiosyncrasies of computing systems such as why a compiler might restrict the values of a data type from -32,768 to 32,767. In addition, it shows how some bugs occur in program due to the misuse of data types.

# * [Problems]()

# 2. [Chapter Two: Numbering Systems]()

Chapter one discussed how computers remember numbers using transistors, tiny devices that act like switches with only two positions, on or off. A single transistor, therefore, can only remember one of two possible numbers, a one or a zero. This is not useful for anything more complex than controlling a light bulb, so for larger values, transistors are grouped together so that their combination of ones and zero can be used to represent larger numbers.

This chapter discusses some of the methods that are used to represent numbers with groups of transistors or **bits**. The reader will also be given methods for calculating the minimum and maximum values of each representation based on the number of bits in the group.

# * [2.1 Unsigned Binary Counting]()

The simplest form o numeric representation with bits is **unsigned binary**. When we count wpward through the positive integers using decimal, we start with a 0 in the one's place and increment a value until we reach the upper limit of a single digit, i.e. 9. At that point, we have run out of the "Symbols" we use to count, and we need to increment the next digit, the ten's place. We then reset the one's place to zero, and start the cycle again.

![Screen Shot 2020-06-10 at 19 12 19](https://user-images.githubusercontent.com/24994818/84330922-54feb980-ab4e-11ea-9296-cd06592b85da.png)

Figure 2-2 shows that when counting in binary, we run out of symbols quickly requiring the addition of another "place" only the second increment.

![Screen Shot 2020-06-10 at 19 13 59](https://user-images.githubusercontent.com/24994818/84330983-8e372980-ab4e-11ea-9426-aefc8ba399ea.png)

With 2 symbols for each bit, we have 2^n possible combinations of symbols, where n represents the number of bits.	

Figure 2-3 uses 5 bits to count up to decimal 17. Examine each row where a single one position is represent in the binary number. This reveals what that position represents. For example, a binary 01000 is shown to be equivalent to a decimal 8. Therefore, the fourth bit position from the right is the 8`s position.

![Screen Shot 2020-06-10 at 19 15 38](https://user-images.githubusercontent.com/24994818/84331052-c9395d00-ab4e-11ea-9d49-049aa53c66a4.png)

This information will help us develop a method for converting **unsigned binary numbers** to decimal and back to **unsigned binary**.

Some of you may recognize this as "base-2" math. This give us a method for indicating whic representation is being ued when writing a number down on paper. 


# * [2.2 Binary Terminology]()
# * [2.3 Unsigned Binary to Decimal Conversion]()
# * [2.4 Decimal to Unsigned Binary Conversion]()
# * [2.5 Binary Representation of Analog Values]()
# * [2.6 Sampling Theory]()
# * [2.7 Hexadecimal Representation]()
# * [2.8 Binary Coded Decimal]()
# * [2.9 Gray Codes]()
# * [2.10 What's Next?]()
# * [Problems]()

# 3. [Chapter Three: Binary Math and Signed Representations]()
# * [3.1 Binary Addition]()
# * [3.2 Binary Subtraction]()
# * [3.3 Binary Complements]()
# * [3.3.1 One's Complement]()
# * [3.3.2 Two's Complement]()
# * [3.3.3 Most Significant Bit as a Sign Indicator]()
# * [3.3.4 Signed Magnitude]()
# * [3.3.5 MSB and Number of Bits]()
# * [3.3.6 Issues Surrounding the Conversion of Binary Numbers. 52 ]()
# * [3.3.7 Minimums and Maximums]()
# * [3.4 Floating Point Binary]()
# * [3.5 Hexadecimal Addition]()
# * [3.6 BCD Addition]()
# * [3.7 Multiplication and Division by Powers of Two]()
# * [3.8 Easy Decimal to Binary Conversion Trick]()
# * [3.9 Arithmetic Overflow]()
# * [3.10 What's Next?]()
# * [Problems]()

# 4. [Chapter Four: Logic Functions and Gates]()
# * [4.1 Logic Gate Basics]()
# * [4.1.1 NOT Gate]()
# * [4.1.2 AND Gate]()
# * [4.1.3 OR Gate]()
# * [4.1.4 Exclusive-OR (XOR) Gate]()
# * [4.2 Truth Tables]()
# * [4.3 Timing Diagrams for Gates]()
# * [4.4 Combinational Logic]()
# * [4.5 Truth Tables for Combinational Logic]()
# * [4.6 What's Next?]()
# * [Problems]()

# 5. [Chapter Five: Boolean Algebra]()
# * [5.1 Need for Boolean Expressions]()
# * [5.2 Symbols of Boolean Algebra]()
# * [5.3 Boolean Expressions of Combinational Logic]()
# * [5.4 Laws of Boolean Algebra]()
# * [5.5 Rules of Boolean Algebra]()
# * [5.5.1 NOT Rule]()
# * [5.5.2 OR Rules]()
# * [5.5.3 AND Rules]()
# * [5.5.4 XOR Rules]()
# * [5.5.5 Derivation of Other Rules]()
# * [5.6 Simplification]()
# * [5.7 DeMorgan's Theorem]()
# * [5.8 What's Next?]()
# * [Problems]()

# 6. [Chapter Six: Standard Boolean Expression Formats]()
# * [6.1 Sum-of-Products]()
# * [6.2 Converting an SOP Expression to a Truth Table]()
# * [6.3 Converting a Truth Table to an SOP Expression]()
# * [6.4 Product-of-Sums]()
# * [6.5 Converting POS to Truth Table]()
# * [6.6 Converting a Truth Table to a POS Expression]()
# * [6.7 NAND-NAND Logic]()
# * [6.8 What's Next?]()
# * [Problems]()

# 7. [Chapter Seven: Karnaugh Maps]()
# * [7.1 The Karnaugh Map]()
# * [7.2 Using Karnaugh Maps]()
# * [7.3 "Don't Care" Conditions in a Karnaugh Map]()
# * [7.4 What's Next?]()
# * [Problems]()

# 8. [Chapter Eight: Combinational Logic Applications]()
# * [8.1 Adders]()
# * [8.2 Seven-Segment Displays]()
# * [8.3 Active-Low Signals]()
# * [8.4 Decoders]()
# * [8.5 Multiplexers]()
# * [8.6 Demultiplexers]()
# * [8.7 Integrated Circuits]()
# * [8.8 What's Next?]()
# * [Problems]()

# 9. [Chapter Nine: Binary Operation Applications]()
# * [9.1 Bitwise Operations]()
# * [9.2 Comparing Bits with XOR]()
# * [9.3 Parity]()
# * [9.4 Checksum]()
# * [9.5 Cyclic Redundancy Check]()
# * [9.5.1 CRC Process]()
# * [9.5.2 CRC Implementation]()
# * [9.6 Hamming Code]()
# * [9.7 What's Next?]()
# * [Problems]()

# 10. [Chapter Ten: Memory Cells]()
# * [10.1 New Truth Table Symbols]()
# * [10.1.1 Edges/Transitions]()
# * [10.1.2 Previously Stored Values]()
# * [10.1.3 Undefined Values]()
# * [10.2 The S-R Latch]()
# * [10.3 The D Latch]()
# * [10.4 Divide-By-Two Circuit]()
# * [10.5 Counter]()
# * [10.6 Parallel Data Output]()
# * [10.7 What's Next?]()
# * [Problems]()

# 11.[ Chapter Eleven: State Machines]()
# * [11.1 Introduction to State Machines]()
# * [11.1.1 States]()
# * [11.1.2 State Diagrams]()
# * [11.1.3 Errors in State Diagrams]()
# * [11.1.4 Basic Circuit Organization]()
# * [11.2 State Machine Design Process]()
# * [11.3 Another State Machine Design: Pattern Detection]()
# * [11.4 Mealy Versus Moore State Machines]()
# * [11.5 What's Next?]()
# * [Problems]()

12. [Chapter Twelve: Memory Organization]()
# * [12.1 Early Memory]()
# * [12.2 Organization of Memory Device]()
# * [12.3 Interfacing Memory to a Processor]()
# * [12.3.1 Buses]()
# * [12.3.2 Memory Maps]()
# * [12.3.3 Address Decoding]()
# * [12.3.4 Chip Select Hardware]()
# * [12.4 Memory Mapped Input/Output]()
# * [12.5 Memory Terminology]()
# * [12.5.1 Random Access Memory]()
# * [12.5.2 Read Only Memory]()
# * [12.5.3 Static RAM versus Dynamic RAM]()
# * [12.5.4 Types of DRAM and Their Timing]()
# * [12.5.5 Asynchronous vs. Synchronous Memory]()
# * [12.6 What's Next?]()
# * [Problems]()

# 13.[ Chapter Thirteen: Memory Hierarchy]()
# * [13.1 Characteristics of the Memory Hierarchy]()
# * [13.2 Physical Characteristics of a Hard Drive]()
# * [13.2.1 Hard Drive Read/Write Head]()
# * [13.2.2 Data Encoding]()
# * [13.2.3 Hard Drive Access Time]()
# * [13.2.4 S.M.A.R.T.]()
# * [13.3 Organization of Data on a Hard Drive]()
# * [13.4 Cache RAM]()
# * [13.4.1 Cache Organization]()
# * [13.4.2 Dividing Memory into Blocks]()
# * [13.4.3 Cache Operation]()
# * [13.4.4 Cache Characteristics]()
# * [13.4.5 Cache Mapping Functions]()
# * [13.4.6 Cache Write Policy]()
# * [13.5 Registers]()
# * [13.6 What's Next?]()
# * [Problems]()

# 14.[ Chapter Fourteen: Serial Protocol Basics]()
# * [14.1 OSI Seven-Layer Network Model]()
# * [14.2 Serial versus Parallel Data Transmission]()
# * [14.3 Anatomy of a Frame or Packet]()
# * [14.4 Sample Protocol: IEEE 802.3 Ethernet]()
# * [14.5 Sample Protocol: Internet Protocol]()
# * [14.6 Sample Protocol: Transmission Control Protocol]()
# * [14.7 Dissecting a Frame]()
# * [14.8 Additional Resources]()
# * [14.9 What's Next?]()
# * [Problems]()

# 15.[ Chapter Fifteen: Introduction to Processor Architecture]()
# * [15.1 Organization versus Architecture]()
# * [15.2 Components]()
# * [15.2.1 Bus]()
# * [15.2.2 Registers]()
# * [15.2.3 Flags]()
# * [15.2.4 Buffers]()
# * [15.2.5 The Stack]()
# * [15.2.6 I/O Ports]()
# * [15.3 Processor Level]()
# * [15.4 CPU Level]()
# * [15.5 Simple Example of CPU Operation]()
# * [15.6 Assembly and Machine Language]()
# * [15.7 Big-Endian/Little-Endian]()
# * [15.8 Pipelined Architectures]()
# * [15.9 Passing Data To and From Peripherals]()
# * [15.9.1 Memory-Mapped I/O]()
# * [15.9.2 Polling]()
# * [15.9.3 Interrupts]()
# * [15.9.4 Direct Memory Access]()
# * [15.9.5 I/O Channels and Processors]()
# * [15.10 What's Next?]()
# * [Problems]()

# 16.[ Chapter Sixteen: Intel 80x86 Base Architecture]()
# * [16.1 Why Study the 80x86?]()
# * [16.2 Execution Unit]()
# * [16.2.1 General Purpose Registers]()
# * [16.2.2 Address Registers]()
# * [16.2.3 Flags]()
# * [16.2.4 Internal Buses]()
# * [16.3 Bus Interface Unit]()
# * [16.3.1 Segment Addressing]()
# * [16.3.2 Instruction Queue]()
# * [16.4 Memory versus I/O Ports]()
# * [16.5 What's Next?]()
# * [Problems]()

# 17.[ Chapter Seventeen: Intel 80x86 Assembly Language]()
# * [17.1 Assemblers versus Compilers]()
# * [17.2 Components of a Line of Assembly Language]()
# * [17.3 Assembly Language Directives]()
# * [17.3.1 SEGMENT Directive]()
# * [17.3.2 .MODEL, .STACK, .DATA, and .CODE Directives . 380 ]()
# * [17.3.3 PROC Directive]()
# * [17.3.4 END Directive]()
# * [17.3.5 Data Definition Directives]()
# * [17.3.6 EQU Directive]()
# * [17.4 80x86 Opcodes]()
# * [17.4.1 Data Transfer]()
# * [17.4.2 Data Manipulation]()
# * [17.4.3 Program Control]()
# * [17.4.4 Special Operations]()
# * [17.5 Addressing Modes]()
# * [17.5.1 Register Addressing]()
# * [17.5.2 Immediate Addressing]()
# * [17.5.3 Pointer Addressing]()
# * [17.6 Sample 80x86 Assembly Language Programs]()
# * [17.7 Additional 80x86 Programming Resources]()
# * [17.8 What's Next?]()
# * [Problems]()


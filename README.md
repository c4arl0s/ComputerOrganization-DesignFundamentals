# Computer Organization and Design Fundamentals

# 1. [Chapter One: Digital Signals and Systems]()
# 2. [Chapter Two: Numbering Systems]()
# 3. [Chapter Three: Binary Math and Signed Representations]()
# 4. [Chapter Four: Logic Functions and Gates]()
# 5. [Chapter Five: Boolean Algebra]()
# 6. [Chapter Six: Standard Boolean Expression Formats]()
# 7. [Chapter Seven: Karnaugh Maps]()
# 8. [Chapter Eight: Combinational Logic Applications]()
# 9. [Chapter Nine: Binary Operation Applications]()
# 10.[ Chapter Ten: Memory Cells]()
# 11.[ Chapter Eleven: State Machines]()
# 12.[ Chapter Twelve: Memory Organization]()
# 13.[ Chapter Thirteen: Memory Hierarchy]()
# 14.[ Chapter Fourteen: Serial Protocol Basics]()
# 15.[ Chapter Fifteen: Introduction to Processor Architecture]()
# 16.[ Chapter Sixteen: Intel 80x86 Base Architecture]()

# 1. [Chapter One: Digital Signals and Systems]()
 * [1.1 Should Software Engineers Worry About Hardware?]()
 * [1.2 Non-Digital Signal]()
 * [1.3 Digital Signals]()
 * [1.4 Conversion Systems]()
 * [1.5 Representation of Digital Signals]()
 * [1.6 Types of Digital Signals]()
 * [1.6.1 Edges]()
 * [1.6.2 Pulses]()
 * [1.6.3 Non-Periodic Pulse Trains]()
 * [1.6.4 Periodic Pulse Trains]()
 * [1.6.5 Pulse-Width Modulation]()
 * [1.7 Unit Prefixes]()
 * [1.8 What's Next?]()
 * [Problems]()

# 2. [Chapter Two: Numbering Systems]()
 * [2.1 Unsigned Binary Counting]()
 * [2.2 Binary Terminology]()
 * [2.3 Unsigned Binary to Decimal Conversion]()
 * [2.4 Decimal to Unsigned Binary Conversion]()
 * [2.5 Binary Representation of Analog Values]()
 * [2.6 Sampling Theory]()
 * [2.7 Hexadecimal Representation]()
 * [2.8 Binary Coded Decimal]()
 * [2.9 Gray Codes]()
 * [2.10 What's Next?]()
 * [Problems]()

# 3. [Chapter Three: Binary Math and Signed Representations]()
 * [3.1 Binary Addition]()
 * [3.2 Binary Subtraction]()
 * [3.3 Binary Complements]()
 * [3.3.1 One's Complement]()
 * [3.3.2 Two's Complement]()
 * [3.3.3 Most Significant Bit as a Sign Indicator]()
 * [3.3.4 Signed Magnitude]()
 * [3.3.5 MSB and Number of Bits]()
 * [3.3.6 Issues Surrounding the Conversion of Binary Numbers. 52 ]()
 * [3.3.7 Minimums and Maximums]()
 * [3.4 Floating Point Binary]()
 * [3.5 Hexadecimal Addition]()
 * [3.6 BCD Addition]()
 * [3.7 Multiplication and Division by Powers of Two]()
 * [3.8 Easy Decimal to Binary Conversion Trick]()
 * [3.9 Arithmetic Overflow]()
 * [3.10 What's Next?]()
 * [Problems]()

# 4. [Chapter Four: Logic Functions and Gates]()
 * [4.1 Logic Gate Basics]()
 * [4.1.1 NOT Gate]()
 * [4.1.2 AND Gate]()
 * [4.1.3 OR Gate]()
 * [4.1.4 Exclusive-OR (XOR) Gate]()
 * [4.2 Truth Tables]()
 * [4.3 Timing Diagrams for Gates]()
 * [4.4 Combinational Logic]()
 * [4.5 Truth Tables for Combinational Logic]()
 * [4.6 What's Next?]()
 * [Problems]()

# 5. [Chapter Five: Boolean Algebra]()
 * [5.1 Need for Boolean Expressions]()
 * [5.2 Symbols of Boolean Algebra]()
 * [5.3 Boolean Expressions of Combinational Logic]()
 * [5.4 Laws of Boolean Algebra]()
 * [5.5 Rules of Boolean Algebra]()
 * [5.5.1 NOT Rule]()
 * [5.5.2 OR Rules]()
 * [5.5.3 AND Rules]()
 * [5.5.4 XOR Rules]()
 * [5.5.5 Derivation of Other Rules]()
 * [5.6 Simplification]()
 * [5.7 DeMorgan's Theorem]()
 * [5.8 What's Next?]()
 * [Problems]()

# 6. [Chapter Six: Standard Boolean Expression Formats]()
 * [6.1 Sum-of-Products]()
 * [6.2 Converting an SOP Expression to a Truth Table]()
 * [6.3 Converting a Truth Table to an SOP Expression]()
 * [6.4 Product-of-Sums]()
 * [6.5 Converting POS to Truth Table]()
 * [6.6 Converting a Truth Table to a POS Expression]()
 * [6.7 NAND-NAND Logic]()
 * [6.8 What's Next?]()
 * [Problems]()

# 7. [Chapter Seven: Karnaugh Maps]()
 * [7.1 The Karnaugh Map]()
 * [7.2 Using Karnaugh Maps]()
 * [7.3 "Don't Care" Conditions in a Karnaugh Map]()
 * [7.4 What's Next?]()
 * [Problems]()

# 8. [Chapter Eight: Combinational Logic Applications]()
 * [8.1 Adders]()
 * [8.2 Seven-Segment Displays]()
 * [8.3 Active-Low Signals]()
 * [8.4 Decoders]()
 * [8.5 Multiplexers]()
 * [8.6 Demultiplexers]()
 * [8.7 Integrated Circuits]()
 * [8.8 What's Next?]()
 * [Problems]()

# 9. [Chapter Nine: Binary Operation Applications]()
 * [9.1 Bitwise Operations]()
 * [9.2 Comparing Bits with XOR]()
 * [9.3 Parity]()
 * [9.4 Checksum]()
 * [9.5 Cyclic Redundancy Check]()
 * [9.5.1 CRC Process]()
 * [9.5.2 CRC Implementation]()
 * [9.6 Hamming Code]()
 * [9.7 What's Next?]()
 * [Problems]()

# 10.[ Chapter Ten: Memory Cells]()
 * [10.1 New Truth Table Symbols]()
 * [10.1.1 Edges/Transitions]()
 * [10.1.2 Previously Stored Values]()
 * [10.1.3 Undefined Values]()
 * [10.2 The S-R Latch]()
 * [10.3 The D Latch]()
 * [10.4 Divide-By-Two Circuit]()
 * [10.5 Counter]()
 * [10.6 Parallel Data Output]()
 * [10.7 What's Next?]()
 * [Problems]()

# 11.[ Chapter Eleven: State Machines]()
 * [11.1 Introduction to State Machines]()
 * [11.1.1 States]()
 * [11.1.2 State Diagrams]()
 * [11.1.3 Errors in State Diagrams]()
 * [11.1.4 Basic Circuit Organization]()
 * [11.2 State Machine Design Process]()
 * [11.3 Another State Machine Design: Pattern Detection]()
 * [11.4 Mealy Versus Moore State Machines]()
 * [11.5 What's Next?]()
 * [Problems]()

# 12.[ Chapter Twelve: Memory Organization]()
 * [12.1 Early Memory]()
 * [12.2 Organization of Memory Device]()
 * [12.3 Interfacing Memory to a Processor]()
 * [12.3.1 Buses]()
 * [12.3.2 Memory Maps]()
 * [12.3.3 Address Decoding]()
 * [12.3.4 Chip Select Hardware]()
 * [12.4 Memory Mapped Input/Output]()
 * [12.5 Memory Terminology]()
 * [12.5.1 Random Access Memory]()
 * [12.5.2 Read Only Memory]()
 * [12.5.3 Static RAM versus Dynamic RAM]()
 * [12.5.4 Types of DRAM and Their Timing]()
 * [12.5.5 Asynchronous vs. Synchronous Memory]()
 * [12.6 What's Next?]()
 * [Problems]()

# 13.[ Chapter Thirteen: Memory Hierarchy]()
 * [13.1 Characteristics of the Memory Hierarchy]()
 * [13.2 Physical Characteristics of a Hard Drive]()
 * [13.2.1 Hard Drive Read/Write Head]()
 * [13.2.2 Data Encoding]()
 * [13.2.3 Hard Drive Access Time]()
 * [13.2.4 S.M.A.R.T.]()
 * [13.3 Organization of Data on a Hard Drive]()
 * [13.4 Cache RAM]()
 * [13.4.1 Cache Organization]()
 * [13.4.2 Dividing Memory into Blocks]()
 * [13.4.3 Cache Operation]()
 * [13.4.4 Cache Characteristics]()
 * [13.4.5 Cache Mapping Functions]()
 * [13.4.6 Cache Write Policy]()
 * [13.5 Registers]()
 * [13.6 What's Next?]()
 * [Problems]()

# 14.[ Chapter Fourteen: Serial Protocol Basics]()
 * [14.1 OSI Seven-Layer Network Model]()
 * [14.2 Serial versus Parallel Data Transmission]()
 * [14.3 Anatomy of a Frame or Packet]()
 * [14.4 Sample Protocol: IEEE 802.3 Ethernet]()
 * [14.5 Sample Protocol: Internet Protocol]()
 * [14.6 Sample Protocol: Transmission Control Protocol]()
 * [14.7 Dissecting a Frame]()
 * [14.8 Additional Resources]()
 * [14.9 What's Next?]()
 * [Problems]()

# 15.[ Chapter Fifteen: Introduction to Processor Architecture]()
 * [15.1 Organization versus Architecture]()
 * [15.2 Components]()
 * [15.2.1 Bus]()
 * [15.2.2 Registers]()
 * [15.2.3 Flags]()
 * [15.2.4 Buffers]()
 * [15.2.5 The Stack]()
 * [15.2.6 I/O Ports]()
 * [15.3 Processor Level]()
 * [15.4 CPU Level]()
 * [15.5 Simple Example of CPU Operation]()
 * [15.6 Assembly and Machine Language]()
 * [15.7 Big-Endian/Little-Endian]()
 * [15.8 Pipelined Architectures]()
 * [15.9 Passing Data To and From Peripherals]()
 * [15.9.1 Memory-Mapped I/O]()
 * [15.9.2 Polling]()
 * [15.9.3 Interrupts]()
 * [15.9.4 Direct Memory Access]()
 * [15.9.5 I/O Channels and Processors]()
 * [15.10 What's Next?]()
 * [Problems]()

# 16.[ Chapter Sixteen: Intel 80x86 Base Architecture]()
 * [16.1 Why Study the 80x86?]()
 * [16.2 Execution Unit]()
 * [16.2.1 General Purpose Registers]()
 * [16.2.2 Address Registers]()
 * [16.2.3 Flags]()
 * [16.2.4 Internal Buses]()
 * [16.3 Bus Interface Unit]()
 * [16.3.1 Segment Addressing]()
 * [16.3.2 Instruction Queue]()
 * [16.4 Memory versus I/O Ports]()
 * [16.5 What's Next?]()
 * [Problems]()

# 17.[ Chapter Seventeen: Intel 80x86 Assembly Language]()
 * [17.1 Assemblers versus Compilers]()
 * [17.2 Components of a Line of Assembly Language]()
 * [17.3 Assembly Language Directives]()
 * [17.3.1 SEGMENT Directive]()
 * [17.3.2 .MODEL, .STACK, .DATA, and .CODE Directives . 380 ]()
 * [17.3.3 PROC Directive]()
 * [17.3.4 END Directive]()
 * [17.3.5 Data Definition Directives]()
 * [17.3.6 EQU Directive]()
 * [17.4 80x86 Opcodes]()
 * [17.4.1 Data Transfer]()
 * [17.4.2 Data Manipulation]()
 * [17.4.3 Program Control]()
 * [17.4.4 Special Operations]()
 * [17.5 Addressing Modes]()
 * [17.5.1 Register Addressing]()
 * [17.5.2 Immediate Addressing]()
 * [17.5.3 Pointer Addressing]()
 * [17.6 Sample 80x86 Assembly Language Programs]()
 * [17.7 Additional 80x86 Programming Resources]()
 * [17.8 What's Next?]()
 * [Problems]()


# Computer Organization and Design Fundamentals

# 1. [Chapter One: Digital Signals and Systems]()

Knowing how to design and build a computer may not be vital to the computer professional, but it goes a long way toward improving their skills, but example, making them better drivers.

The principles of computer organization provide tools to create better designs.

	* System Design Tools.
	* Software Design Tools.
	* Improved troubleshooting skills.
	* Interconnectivity
	* Marketability

> When you control parts design, you can integrate the whole package much more elegantly.

# * [1.1 Should Software Engineers Worry About Hardware?]()

The real world is analog. When values such as temperature or weight change over time, they follow what is called a **continuous curve**. It is sufficient to say that analog values represent a continuous signal with infinitesimal resolution.

![Screen Shot 2020-06-05 at 15 23 34](https://user-images.githubusercontent.com/24994818/83919628-9f43fd00-a740-11ea-910f-f5257759b79e.png)

# * [1.2 Non-Digital Signal]()

There is such a thing as an analog computer, a computer that processes information using analog levels of electricity or the positions of mechanical devices. Now computers represent an analog value by converting it to a number with a fixed resolution. This measurement is referred to as a **digital value**.

![Screen Shot 2020-06-06 at 13 03 35](https://user-images.githubusercontent.com/24994818/83951299-269f7800-a7f6-11ea-858b-63451d4794b2.png)

The computer can only measure the signal at intervals. Each measurement is called a **sample**. The rate at which these samples are taken is called the **Sampling rate**.

![Screen Shot 2020-06-06 at 13 05 13](https://user-images.githubusercontent.com/24994818/83951333-61091500-a7f6-11ea-9c89-f0d55adb0702.png)

Two problem arise from this process: information can be lost between the measurement and information can be lost due to the **rounding** of the measurement. First, if the sampling rate is too slow, the some details of the signal may be missed.

![Screen Shot 2020-06-06 at 13 07 18](https://user-images.githubusercontent.com/24994818/83951375-ac232800-a7f6-11ea-8b82-7b3a0126502b.png)

Second, if the computer does not record with enough accuracy an error may be introduced between the actual measurement and the recorded value.

![Screen Shot 2020-06-06 at 13 08 48](https://user-images.githubusercontent.com/24994818/83951394-e42a6b00-a7f6-11ea-87a2-fff593ffe989.png)

These effects can be reduced by increasing the resolution of the measurement and increasing the sampling rate. A discussion of this can be found in Chapter 2 in the section titled "Sampling Theory"	

# * [1.3 Digital Signals]()
# * [1.4 Conversion Systems]()
# * [1.5 Representation of Digital Signals]()
# * [1.6 Types of Digital Signals]()
# * [1.6.1 Edges]()
# * [1.6.2 Pulses]()
# * [1.6.3 Non-Periodic Pulse Trains]()
# * [1.6.4 Periodic Pulse Trains]()
# * [1.6.5 Pulse-Width Modulation]()
# * [1.7 Unit Prefixes]()
# * [1.8 What's Next?]()
# * [Problems]()

# 2. [Chapter Two: Numbering Systems]()
# * [2.1 Unsigned Binary Counting]()
# * [2.2 Binary Terminology]()
# * [2.3 Unsigned Binary to Decimal Conversion]()
# * [2.4 Decimal to Unsigned Binary Conversion]()
# * [2.5 Binary Representation of Analog Values]()
# * [2.6 Sampling Theory]()
# * [2.7 Hexadecimal Representation]()
# * [2.8 Binary Coded Decimal]()
# * [2.9 Gray Codes]()
# * [2.10 What's Next?]()
# * [Problems]()

# 3. [Chapter Three: Binary Math and Signed Representations]()
# * [3.1 Binary Addition]()
# * [3.2 Binary Subtraction]()
# * [3.3 Binary Complements]()
# * [3.3.1 One's Complement]()
# * [3.3.2 Two's Complement]()
# * [3.3.3 Most Significant Bit as a Sign Indicator]()
# * [3.3.4 Signed Magnitude]()
# * [3.3.5 MSB and Number of Bits]()
# * [3.3.6 Issues Surrounding the Conversion of Binary Numbers. 52 ]()
# * [3.3.7 Minimums and Maximums]()
# * [3.4 Floating Point Binary]()
# * [3.5 Hexadecimal Addition]()
# * [3.6 BCD Addition]()
# * [3.7 Multiplication and Division by Powers of Two]()
# * [3.8 Easy Decimal to Binary Conversion Trick]()
# * [3.9 Arithmetic Overflow]()
# * [3.10 What's Next?]()
# * [Problems]()

# 4. [Chapter Four: Logic Functions and Gates]()
# * [4.1 Logic Gate Basics]()
# * [4.1.1 NOT Gate]()
# * [4.1.2 AND Gate]()
# * [4.1.3 OR Gate]()
# * [4.1.4 Exclusive-OR (XOR) Gate]()
# * [4.2 Truth Tables]()
# * [4.3 Timing Diagrams for Gates]()
# * [4.4 Combinational Logic]()
# * [4.5 Truth Tables for Combinational Logic]()
# * [4.6 What's Next?]()
# * [Problems]()

# 5. [Chapter Five: Boolean Algebra]()
# * [5.1 Need for Boolean Expressions]()
# * [5.2 Symbols of Boolean Algebra]()
# * [5.3 Boolean Expressions of Combinational Logic]()
# * [5.4 Laws of Boolean Algebra]()
# * [5.5 Rules of Boolean Algebra]()
# * [5.5.1 NOT Rule]()
# * [5.5.2 OR Rules]()
# * [5.5.3 AND Rules]()
# * [5.5.4 XOR Rules]()
# * [5.5.5 Derivation of Other Rules]()
# * [5.6 Simplification]()
# * [5.7 DeMorgan's Theorem]()
# * [5.8 What's Next?]()
# * [Problems]()

# 6. [Chapter Six: Standard Boolean Expression Formats]()
# * [6.1 Sum-of-Products]()
# * [6.2 Converting an SOP Expression to a Truth Table]()
# * [6.3 Converting a Truth Table to an SOP Expression]()
# * [6.4 Product-of-Sums]()
# * [6.5 Converting POS to Truth Table]()
# * [6.6 Converting a Truth Table to a POS Expression]()
# * [6.7 NAND-NAND Logic]()
# * [6.8 What's Next?]()
# * [Problems]()

# 7. [Chapter Seven: Karnaugh Maps]()
# * [7.1 The Karnaugh Map]()
# * [7.2 Using Karnaugh Maps]()
# * [7.3 "Don't Care" Conditions in a Karnaugh Map]()
# * [7.4 What's Next?]()
# * [Problems]()

# 8. [Chapter Eight: Combinational Logic Applications]()
# * [8.1 Adders]()
# * [8.2 Seven-Segment Displays]()
# * [8.3 Active-Low Signals]()
# * [8.4 Decoders]()
# * [8.5 Multiplexers]()
# * [8.6 Demultiplexers]()
# * [8.7 Integrated Circuits]()
# * [8.8 What's Next?]()
# * [Problems]()

# 9. [Chapter Nine: Binary Operation Applications]()
# * [9.1 Bitwise Operations]()
# * [9.2 Comparing Bits with XOR]()
# * [9.3 Parity]()
# * [9.4 Checksum]()
# * [9.5 Cyclic Redundancy Check]()
# * [9.5.1 CRC Process]()
# * [9.5.2 CRC Implementation]()
# * [9.6 Hamming Code]()
# * [9.7 What's Next?]()
# * [Problems]()

# 10. [Chapter Ten: Memory Cells]()
# * [10.1 New Truth Table Symbols]()
# * [10.1.1 Edges/Transitions]()
# * [10.1.2 Previously Stored Values]()
# * [10.1.3 Undefined Values]()
# * [10.2 The S-R Latch]()
# * [10.3 The D Latch]()
# * [10.4 Divide-By-Two Circuit]()
# * [10.5 Counter]()
# * [10.6 Parallel Data Output]()
# * [10.7 What's Next?]()
# * [Problems]()

# 11.[ Chapter Eleven: State Machines]()
# * [11.1 Introduction to State Machines]()
# * [11.1.1 States]()
# * [11.1.2 State Diagrams]()
# * [11.1.3 Errors in State Diagrams]()
# * [11.1.4 Basic Circuit Organization]()
# * [11.2 State Machine Design Process]()
# * [11.3 Another State Machine Design: Pattern Detection]()
# * [11.4 Mealy Versus Moore State Machines]()
# * [11.5 What's Next?]()
# * [Problems]()

12. [Chapter Twelve: Memory Organization]()
# * [12.1 Early Memory]()
# * [12.2 Organization of Memory Device]()
# * [12.3 Interfacing Memory to a Processor]()
# * [12.3.1 Buses]()
# * [12.3.2 Memory Maps]()
# * [12.3.3 Address Decoding]()
# * [12.3.4 Chip Select Hardware]()
# * [12.4 Memory Mapped Input/Output]()
# * [12.5 Memory Terminology]()
# * [12.5.1 Random Access Memory]()
# * [12.5.2 Read Only Memory]()
# * [12.5.3 Static RAM versus Dynamic RAM]()
# * [12.5.4 Types of DRAM and Their Timing]()
# * [12.5.5 Asynchronous vs. Synchronous Memory]()
# * [12.6 What's Next?]()
# * [Problems]()

# 13.[ Chapter Thirteen: Memory Hierarchy]()
# * [13.1 Characteristics of the Memory Hierarchy]()
# * [13.2 Physical Characteristics of a Hard Drive]()
# * [13.2.1 Hard Drive Read/Write Head]()
# * [13.2.2 Data Encoding]()
# * [13.2.3 Hard Drive Access Time]()
# * [13.2.4 S.M.A.R.T.]()
# * [13.3 Organization of Data on a Hard Drive]()
# * [13.4 Cache RAM]()
# * [13.4.1 Cache Organization]()
# * [13.4.2 Dividing Memory into Blocks]()
# * [13.4.3 Cache Operation]()
# * [13.4.4 Cache Characteristics]()
# * [13.4.5 Cache Mapping Functions]()
# * [13.4.6 Cache Write Policy]()
# * [13.5 Registers]()
# * [13.6 What's Next?]()
# * [Problems]()

# 14.[ Chapter Fourteen: Serial Protocol Basics]()
# * [14.1 OSI Seven-Layer Network Model]()
# * [14.2 Serial versus Parallel Data Transmission]()
# * [14.3 Anatomy of a Frame or Packet]()
# * [14.4 Sample Protocol: IEEE 802.3 Ethernet]()
# * [14.5 Sample Protocol: Internet Protocol]()
# * [14.6 Sample Protocol: Transmission Control Protocol]()
# * [14.7 Dissecting a Frame]()
# * [14.8 Additional Resources]()
# * [14.9 What's Next?]()
# * [Problems]()

# 15.[ Chapter Fifteen: Introduction to Processor Architecture]()
# * [15.1 Organization versus Architecture]()
# * [15.2 Components]()
# * [15.2.1 Bus]()
# * [15.2.2 Registers]()
# * [15.2.3 Flags]()
# * [15.2.4 Buffers]()
# * [15.2.5 The Stack]()
# * [15.2.6 I/O Ports]()
# * [15.3 Processor Level]()
# * [15.4 CPU Level]()
# * [15.5 Simple Example of CPU Operation]()
# * [15.6 Assembly and Machine Language]()
# * [15.7 Big-Endian/Little-Endian]()
# * [15.8 Pipelined Architectures]()
# * [15.9 Passing Data To and From Peripherals]()
# * [15.9.1 Memory-Mapped I/O]()
# * [15.9.2 Polling]()
# * [15.9.3 Interrupts]()
# * [15.9.4 Direct Memory Access]()
# * [15.9.5 I/O Channels and Processors]()
# * [15.10 What's Next?]()
# * [Problems]()

# 16.[ Chapter Sixteen: Intel 80x86 Base Architecture]()
# * [16.1 Why Study the 80x86?]()
# * [16.2 Execution Unit]()
# * [16.2.1 General Purpose Registers]()
# * [16.2.2 Address Registers]()
# * [16.2.3 Flags]()
# * [16.2.4 Internal Buses]()
# * [16.3 Bus Interface Unit]()
# * [16.3.1 Segment Addressing]()
# * [16.3.2 Instruction Queue]()
# * [16.4 Memory versus I/O Ports]()
# * [16.5 What's Next?]()
# * [Problems]()

# 17.[ Chapter Seventeen: Intel 80x86 Assembly Language]()
# * [17.1 Assemblers versus Compilers]()
# * [17.2 Components of a Line of Assembly Language]()
# * [17.3 Assembly Language Directives]()
# * [17.3.1 SEGMENT Directive]()
# * [17.3.2 .MODEL, .STACK, .DATA, and .CODE Directives . 380 ]()
# * [17.3.3 PROC Directive]()
# * [17.3.4 END Directive]()
# * [17.3.5 Data Definition Directives]()
# * [17.3.6 EQU Directive]()
# * [17.4 80x86 Opcodes]()
# * [17.4.1 Data Transfer]()
# * [17.4.2 Data Manipulation]()
# * [17.4.3 Program Control]()
# * [17.4.4 Special Operations]()
# * [17.5 Addressing Modes]()
# * [17.5.1 Register Addressing]()
# * [17.5.2 Immediate Addressing]()
# * [17.5.3 Pointer Addressing]()
# * [17.6 Sample 80x86 Assembly Language Programs]()
# * [17.7 Additional 80x86 Programming Resources]()
# * [17.8 What's Next?]()
# * [Problems]()

